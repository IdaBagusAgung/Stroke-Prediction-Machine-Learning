# -*- coding: utf-8 -*-
"""STROKE MODEL NEW.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xccgiiRle-y17lq3HhomDbgu724BdAw-

# PREDICTIVE ANALYTICS : STROKE PREDICTION
by : Ida Bagus Agung Bajerapany

![image.png](data:image/png;base64,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)

# DESKRIPSI PROYEK

Proyek prediksi stroke menggunakan machine learning dan deep learning bertujuan untuk mengidentifikasi individu dengan risiko tinggi mengalami stroke melalui analisis data kesehatan. Dengan memanfaatkan algoritma analisis yang canggih, proyek ini akan mengumpulkan dan menganalisis data tentang faktor risiko seperti hipertensi, diabetes, obesitas, dan pola hidup tidak sehat. Model yang dibangun akan membantu dalam mendeteksi pola dan tren yang mungkin tidak terlihat pada analisis tradisional. Dengan melakukan prediksi yang lebih akurat, proyek ini dapat memfasilitasi intervensi dini dan pencegahan, memungkinkan penyedia layanan kesehatan untuk menangani faktor risiko sebelum kondisi menjadi lebih serius. Selain itu, edukasi dan kampanye kesehatan akan mendukung upaya ini, meningkatkan kesadaran masyarakat tentang pencegahan stroke.

# IMPORT LIBRARY YANG DIGUNAKAN
"""

import pandas as pd
import numpy as np
import seaborn as sns
import tensorflow as tf
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings("ignore")

# Library proses pre-processing
from sklearn.compose import ColumnTransformer
from sklearn.preprocessing import OneHotEncoder
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

# Library dalam penerapan SMOTE
from imblearn.over_sampling import SMOTE

# Library penerapan model Machine Learning
from sklearn.linear_model import LogisticRegression
from sklearn.neighbors import KNeighborsClassifier
from sklearn.naive_bayes import GaussianNB
from sklearn.naive_bayes import BernoulliNB
from sklearn.svm import SVC
from sklearn.tree import DecisionTreeClassifier
from sklearn.ensemble import RandomForestClassifier
from xgboost import XGBClassifier

from sklearn.metrics import (accuracy_score, confusion_matrix, roc_auc_score,
                             ConfusionMatrixDisplay, precision_score, recall_score,
                             f1_score, classification_report, auc,
                             precision_recall_curve, average_precision_score)

from sklearn.metrics import roc_curve
from sklearn.metrics import RocCurveDisplay
from sklearn.metrics import PrecisionRecallDisplay
from sklearn.base import BaseEstimator, ClassifierMixin
from sklearn.model_selection import GridSearchCV
from sklearn.model_selection import cross_val_score

# Library penerapan model deep learning
from tensorflow.keras.regularizers import l2
from tensorflow.keras.layers import SimpleRNN
from tensorflow.keras.layers import Dropout
from tensorflow.keras.layers import LSTM, Dense

"""# DATA UNDERSTANDING

Data Understanding merupakan proses memahami informasi dalam data dan menentukan kualitas dari data tersebut. Dalam data understanding ini terdapat beberapa fungsi dari library yang digunakan untuk memahami informasi yang ada pada dataset

## LOAD DATASET

Data loading merupakan tahap krusial dalam proses analisis data yang bertujuan untuk memuat dataset yang akan digunakan, sehingga data menjadi lebih mudah dipahami dan diolah. Pada tahap ini, dataset yang telah dipersiapkan sebelumnya, yang telah melalui proses pembersihan dan normalisasi oleh pembuatnya, siap untuk digunakan. Pembersihan data memastikan bahwa informasi yang terkandung bebas dari kesalahan dan inkonsistensi, sedangkan normalisasi membantu dalam menyelaraskan skala nilai agar siap untuk analisis lebih lanjut. Proses data loading yang efektif juga memfasilitasi integrasi data dari berbagai sumber, meningkatkan efisiensi dan akurasi dalam analisis yang dilakukan.

| Jenis | Keterangan |
| ------ | ------ |
| Title | _Apple Quality_ |
| Source | [Kaggle](https://www.kaggle.com/datasets/fedesoriano/stroke-prediction-dataset) |
| Maintainer | [fedesoriano ⚡](https://www.kaggle.com/fedesoriano) |
| License | Data files © Original Authors |
| Visibility | Publik |
| Tags | _Health, Education, Health Conditions, Public Health, Healthcare, Binary Classification_ |
| View | 1.38M |
"""

data = pd.read_csv('DATASET_STROKE.csv')

"""kode diatas digunkan untuk membaca dataset yang berbentuk csv kedalam variabel data yang akan dilakukan analysis pada proses selanjutnya

## DATASET INFO
"""

data

data.info()

"""- Dataset berupa CSV (Comma-Seperated Values).
- Dataset memiliki 5110 sample dengan 12 fitur.
- Dataset memiliki 3 fitur bertipe float64, 4 fitur bertipe o=int64 dan 5 fitur bertipe object.
- Terdapat 1 missing value dalam dataset pada kolom BMI.

Variable - variable pada dataset
- id: Merupakan pengidentifikasi unik untuk setiap pasien, yang memungkinkan pengelolaan dan pelacakan data dengan lebih efisien.
- gender: Menunjukkan jenis kelamin pasien, yang dapat berupa "Laki-laki", "Perempuan", atau "Lainnya". Atribut ini penting untuk analisis perbedaan risiko berdasarkan gender.
- age: Menunjukkan usia pasien, yang merupakan faktor kunci dalam penilaian risiko stroke, karena kecenderungan serangan stroke meningkat seiring bertambahnya usia.
- hypertension: Indikator yang menunjukkan apakah pasien menderita hipertensi atau tidak, diwakili dengan nilai 0 jika tidak mengalami hipertensi dan 1 jika mengalami hipertensi. Hipertensi adalah salah satu faktor risiko utama untuk stroke.
- heart_disease: Menunjukkan apakah pasien memiliki penyakit jantung, dengan nilai 0 untuk tidak ada penyakit jantung dan 1 untuk memiliki penyakit jantung. Keberadaan penyakit jantung dapat meningkatkan risiko stroke secara signifikan.
- ever_married: Menunjukkan status pernikahan pasien, dengan opsi "Tidak" atau "Ya". Status pernikahan dapat berhubungan dengan berbagai faktor sosial dan emosional yang memengaruhi kesehatan.
- work_type: Kategori pekerjaan pasien, yang bisa berupa "anak-anak", "Pekerjaan Pemerintah", "Belum pernah bekerja", "Swasta", atau "Wiraswasta". Tipe pekerjaan dapat memberikan wawasan tentang paparan stres dan faktor risiko terkait pekerjaan.
- Residence_type: Menunjukkan jenis tempat tinggal pasien, apakah berada di "Pedesaan" atau "Perkotaan". Lingkungan tempat tinggal dapat mempengaruhi akses terhadap pelayanan kesehatan yang berkualitas.
- avg_glucose_level: Menyediakan informasi tentang rata-rata kadar glukosa dalam darah pasien. Kadar glukosa yang tinggi dapat menjadi indikator risiko penyakit metabolik yang berkaitan dengan stroke.
- bmi: Body Mass Index (Indeks Massa Tubuh) pasien, yang merupakan ukuran untuk menentukan apakah seseorang memiliki berat badan yang sehat, berlebih, atau kurang. BMI yang tidak normal dapat berkontribusi pada risiko penyakit cardiovascular, termasuk stroke.
- smoking_status: Menunjukkan status merokok pasien, yang dapat berupa "pernah merokok", "tidak pernah merokok", "sedang merokok" atau "Tidak Diketahui". Merokok adalah faktor risiko yang signifikan untuk banyak penyakit, termasuk stroke.
- stroke: Indikator yang menunjukkan apakah pasien pernah mengalami stroke, diwakili dengan nilai 1 jika pernah mengalami stroke dan 0 jika tidak. Atribut ini merupakan hasil yang ingin diprediksi dalam model analisis risiko stroke.
Informasi di atas mencakup berbagai faktor demografis, kesehatan, dan gaya hidup yang relevan dalam menentukan risiko stroke, dan dapat digunakan untuk memfasilitasi pengembangan model prediksi yang lebih akurat.

# DATA UNDERSTANDING (EDA)

Exploratory Data Analysis (EDA) merupakn proses investigasi awal yang sangat penting dalam analisis data, di mana kita melakukan analisis menyeluruh terhadap karakteristik dataset untuk mengungkap berbagai informasi yang terkandung di dalamnya. Dalam tahap ini, tujuan utama adalah untuk memahami struktur dan pola dalam data, menemukan anomali atau outlier yang mungkin menunjukkan kesalahan pencatatan atau fenomena menarik lainnya, serta memeriksa asumsi yang ada tentang hubungan antarvariabel. Teknik EDA memanfaatkan metode statistik deskriptif, seperti penghitungan rata-rata, median, dan standar deviasi, untuk memberikan gambaran numerik tentang data. Selain itu, visualisasi grafis menjadi alat yang sangat efektif dalam EDA; plot dan grafik seperti histogram, scatter plot, dan box plot memungkinkan kita untuk melihat distribusi data, pola, dan hubungan antarvariabel secara lebih jelas.

## INFORMATION DATASET
"""

data.shape

data.describe()

"""Tabel diatas merupakan informasi mengenai dataset yang sigunakan :
- Kolom id berfungsi sebagai pengidentifikasi unik bagi setiap individu, namun statistik deskriptif seperti rata-rata (mean), nilai minimum (min), dan maksimum (max) tidak begitu relevan untuk analisis kolom ini. Kolom age menunjukkan usia individu, dengan rata-rata usia sebesar 43,23 tahun. Usia termuda dalam dataset tercatat adalah 0,08 tahun (mungkin bayi), sementara usia tertua adalah 82 tahun. Distribusi usia juga dapat dilihat dari kuartil, di mana 50% individu berusia 45 tahun atau lebih muda.
- Untuk kolom hypertension, yang merupakan variabel biner (0 atau 1) yang menunjukkan apakah individu memiliki hipertensi, didapatkan rata-rata sebesar 0,097, yang berarti sekitar 9,7% individu dalam dataset memiliki hipertensi. Demikian juga pada kolom heart_disease, yang menunjukkan riwayat penyakit jantung, dengan rata-rata 0,054, mengindikasikan bahwa hanya sekitar 5,4% individu yang mengalami kondisi ini.
- Kolom avg_glucose_level mencerminkan rata-rata kadar glukosa darah individu dengan rata-rata sebesar 106,15 mg/dL, yang termasuk dalam kisaran normal. Namun, nilai maksimum mencapai 271,74 mg/dL, yang bisa mengindikasikan adanya individu dengan diabetes atau hiperglikemia. Median kadar glukosa (50%) adalah 91,89 mg/dL, menunjukkan bahwa setengah dari data berada di bawah nilai tersebut.
- Sedangkan kolom bmi atau Body Mass Index menunjukkan rata-rata BMI sebesar 28,89, yang mendekati kategori overweight berdasarkan pedoman WHO. Nilai maksimum BMI tercatat 97,6, yang menunjukkan kemungkinan adanya outlier, baik karena kesalahan data atau kasus ekstrem obesitas. Penting untuk dicatat bahwa terdapat data kosong, dengan 4.909 data valid dari total 5.110, sehingga perlu penanganan khusus untuk analisis lanjutan.
- Pada kolom stroke, yang merupakan variabel target biner menunjukkan apakah individu pernah mengalami stroke, didapatkan rata-rata 0,048, menandakan sekitar 4,87% individu dalam dataset pernah mengalami stroke. Dari kesimpulan awal, sebagian besar individu dalam dataset tidak memiliki hipertensi, penyakit jantung, ataupun riwayat stroke. Data seperti BMI yang memiliki missing values perlu ditangani sebelum model pemodelan. Selain itu, nilai maksimum pada beberapa kolom, termasuk avg_glucose_level dan bmi, menunjukkan adanya kemungkinan outlier yang dapat memengaruhi hasil analisis atau model prediksi. Faktor usia, hipertensi, penyakit jantung, dan kadar glukosa darah terlihat relevan untuk analisis risiko stroke.

"""

# Memilih hanya kolom numerik
numerical_data = data.select_dtypes(include=['number'])

# Menghitung korelasi
correlation_matrix = numerical_data.corr()

# Menampilkan hasil korelasi
print(correlation_matrix)

correlation_matrix

"""Tabel diatas merupakan korelasi dari masing-masing kolom pada dataset yang terdapat pada dataset

## PENGECEKAN DATA DUPLIKAT DAN KOSONG

Pada proses ini melakukan pengecekan dataset apakah terdapat data duplikat dan kosong pada dataset stroke yang digunakan. Proses ini sangat penting untuk melakukan analysis kedepannya sehingga dapat menghasilkan model yang baik
"""

duplikat = data.duplicated()
print(duplikat.sum())

"""dapat dilihat pada hasil kode diatas, bahwa pada dataset stroke ini tidak ada data yang duplikat atau 0."""

data.isnull().sum()

"""Dapat dilihat pada tabel hasil kode diatas, bahwa terdapat data yang kosong pada kolom BMI sebanyak 201 data

### REPLACE DATA BMI YANG KOSONG DENGAN NILAI RATA-RATA
"""

data.bmi.replace(to_replace=np.nan, value=data.bmi.mean(), inplace=True)

data.isnull().sum()

"""Kode diatas digunakan untuk mengisi kolom BMI yang kosong dengan nilai rata-rata dari BMI

## PENGECEKAN VALUE UNIK YANG ADA PADA DATASET
"""

data.nunique().sort_values(ascending=False)

"""Tabel diatas merupakan jumlah value yang unik pada masing masing kolom yangterdapat pada dataset

## VISUALISASI (UNIVARIATE ANALYSIS)

Univariate analysis merupakan suatu teknik analisis yang memfokuskan pada satu variabel atau atribut saja. Tujuan dari analisis ini adalah untuk memahami distribusi dan karakteristik dari variabel tunggal tersebut. Dalam univariate analysis, data diolah dan disajikan melalui statistik deskriptif seperti mean, median, modus, standar deviasi, dan varians, serta visualisasi grafis seperti histogram, chart, Analisis ini berguna untuk memberikan gambaran awal mengenai pola, kecenderungan, atau distribusi data dari satu variabel sebelum melanjutkan ke analisis yang lebih kompleks.

### KORELASI PADA DATASET
"""

sns.heatmap(data.corr(numeric_only=True),annot=True)
plt.show()

"""Pada Gambar diatas, Analisis Matriks Korelasi, merupakan menunjukkan hubungan antar fitur dalam nilai korelasi. Jika diamati, fitur umur memiliki skor korelasi yang cukup besar 0.28 dengan fitur hipertensi, dan juga fitur berat badan yang cukup besar 0.33 dengan fitur umur.

"""

numerical_data = data.select_dtypes(include=['number'])

# Compute the correlation matrix
corr = numerical_data.corr()

# Generate a mask for the upper triangle
mask = np.triu(np.ones_like(corr, dtype=bool))

# Set up the matplotlib figure
f, ax = plt.subplots(figsize=(11, 9))

# Generate a custom diverging colormap
cmap = sns.diverging_palette(230, 20, as_cmap=True)

# Draw the heatmap with the mask and correct aspect ratio
sns.heatmap(corr, mask=mask, cmap=cmap, vmax=.3, center=0, square=True, linewidths=.5, cbar_kws={"shrink": .5})

"""### VISUALISASI KOLOM

#### VISUALISASI GENDER
"""

print(data.gender.value_counts())

sns.set_theme(style="darkgrid")
ax = sns.countplot(data=data, x="gender")
plt.show()

"""Gambar diatas menampilkan grafik dari persebaran jenis kelamin yang terdapat pada dataset stroke yang digunakan pada proyek ini.

#### VISUALISASI HIPERTENSI
"""

print(data.hypertension.value_counts())

sns.set_theme(style="darkgrid")
ax = sns.countplot(data=data, x="hypertension")
plt.show()

"""Gambar diatas menampilkan grafik dari persebaran hipertensi yang terdapat pada dataset stroke yang digunakan pada proyek ini.

#### VISUALISASI STATUS MENIKAH
"""

print(data.ever_married.value_counts())

sns.set_theme(style="darkgrid")
ax = sns.countplot(data=data, x="ever_married")
plt.show()

"""Gambar diatas menampilkan grafik dari persebaran status menikah yang terdapat pada dataset stroke yang digunakan pada proyek ini.

#### VISUALISASI TIPE PEKERJAAN
"""

print(data.work_type.value_counts())

sns.set_theme(style="darkgrid")
ax = sns.countplot(data=data, x="work_type")
plt.show()

"""Gambar diatas menampilkan grafik dari persebaran tipe pekerjaan yang terdapat pada dataset stroke yang digunakan pada proyek ini.

#### VISUALISASI RESIDENCE TYPE
"""

print(data.Residence_type.value_counts())

sns.set_theme(style="darkgrid")
ax = sns.countplot(data=data, x="Residence_type")
plt.show()

"""Gambar diatas menampilkan grafik dari persebaran tipe tempat tinggal yang terdapat pada dataset stroke yang digunakan pada proyek ini.

#### VISUALISASI SMOKING STATUS
"""

print(data.smoking_status.value_counts())

sns.set_theme(style="darkgrid")
ax = sns.countplot(data=data, x="smoking_status")
ax.set_xticklabels(ax.get_xticklabels(), fontsize=10)
plt.tight_layout()
plt.show()

"""Gambar diatas menampilkan grafik dari persebaran status merokok yang terdapat pada dataset stroke yang digunakan pada proyek ini.

#### VISUALISASI STROKE
"""

print(data.stroke.value_counts())

sns.set_theme(style="darkgrid")
ax = sns.countplot(data=data, x="stroke")
plt.show()

"""Gambar diatas menampilkan grafik dari persebaran stroke yang terdapat pada dataset stroke yang digunakan pada proyek ini.

### DISTRIBUSI DATA PADA DATASET
"""

data.hist(figsize=(10,10))
plt.suptitle('Health Data Distribution: Histogram Analysis', fontsize=16)
plt.show()

"""Gambar diatas menampilkan grafik dari persebaran jenis data kategorikal yang terdapat pada dataset stroke yang digunakan pada proyek ini."""

numerical_columns = data.select_dtypes(include=['int64', 'float64']).columns
n_cols = 4
n_rows = len(numerical_columns) // n_cols + 1

plt.figure(figsize=(15, 5 * n_rows))

# Plot each numerical column as a boxplot
for i, col_name in enumerate(numerical_columns, 1):
    plt.subplot(n_rows, n_cols, i)
    sns.boxplot(y=data[col_name])
    plt.title(col_name)

# Adjust the layout for better spacing
plt.tight_layout()

# Display the plot
plt.show()

"""Gambar diatas menampilkan grafik dari persebaran jenis data numerical yang terdapat pada dataset stroke yang digunakan pada proyek ini.

#### DISTRIBUSI LEVEL GLUKOSA
"""

fig = plt.figure(figsize=(7,7))
sns.distplot(data.avg_glucose_level, color="blue", label="avg_glucose_level", kde= True)
plt.legend()

"""Gambar diatas menampilkan grafik dari persebaran glukosa yang terdapat pada dataset stroke yang digunakan pada proyek ini.

#### DISTRIBUSI BMI
"""

fig = plt.figure(figsize=(7,7))
sns.distplot(data.bmi, color="blue", label="bmi", kde= True)
plt.legend()

"""Gambar diatas menampilkan grafik dari persebaran berat badan yang terdapat pada dataset stroke yang digunakan pada proyek ini.

#### DISTRIBUSI UMUR
"""

fig = plt.figure(figsize=(7, 7))
sns.distplot(data.age, color="blue", label="age", kde=True)
plt.legend()
plt.show()

"""Gambar diatas menampilkan grafik dari persebaran umur yang terdapat pada dataset stroke yang digunakan pada proyek ini.

### GABUNGAN
"""

fig, axs = plt.subplots(3, 3, figsize=(12, 12))
sns.histplot(data=data["bmi"], ax=axs[0, 0])
sns.histplot(data=data["avg_glucose_level"], ax=axs[0, 1])
sns.histplot(data=data["age"], ax=axs[0, 2])
sns.countplot(x = data["stroke"], ax=axs[1, 0])

sns.countplot(x = data["hypertension"], ax=axs[1, 1])
sns.countplot(x = data["heart_disease"], ax=axs[1, 2])
sns.countplot(x = data["ever_married"], ax=axs[2, 0])
sns.countplot(x = data["gender"], ax=axs[2, 1])
sns.countplot(x = data["Residence_type"], ax=axs[2, 2])

plt.show()

"""Gambar diatas menampilkan grafik dari persebaran data yang terdapat pada masing-masing kolom pada dataset yang terdapat pada dataset stroke yang digunakan pada proyek ini.

## VISUALISASI (BIVARIATE ANALYSIS)

Bivariate analysis merupakan teknik analisis yang melibatkan dua variabel untuk mengeksplorasi hubungan dan interaksi antara keduanya. Tujuan dari analisis ini adalah untuk memahami bagaimana satu variabel dapat mempengaruhi atau berhubungan dengan variabel lainnya. Bivariate analysis sering kali menggunakan teknik statistik seperti korelasi. Visualisasi grafis yang umum digunakan dalam bivariate analysis mencakup scatter plot dan diagram kontingensi. Melalui analisis ini, kita dapat mengidentifikasi pola hubungan, apakah positif, negatif, atau tidak ada hubungan antara dua variabel.
"""

category_column = ["gender","hypertension","heart_disease","ever_married","work_type","Residence_type","smoking_status","stroke"]
continouse_column = ["age","avg_glucose_level","bmi"]

"""membagi kolom yang terdapat pada data kedalam dua jenis yaitu kedalam data kategori dan data kontinu"""

cr = data[continouse_column].corr(method='pearson')
plt.figure(figsize = (6,6))
sns.heatmap(cr,cmap="coolwarm")
plt.show()

"""gambar diatas merupakan heatmap dari data kontinu yang terdapat pada dataset stroke yang digunakan pada proyek ini.

### AGE vs GLUCOSE dengan Stroke
"""

plt.figure(figsize=(8,8))
sns.set_style("darkgrid")
sns.scatterplot(data = data, x = 'age', y = 'avg_glucose_level', hue='stroke')
plt.show()

"""Grafik scatterplot diatas memberikan gambaran awal yang menarik tentang hubungan antara usia, tingkat glukosa, dan risiko stroke. Namun, untuk mendapatkan pemahaman yang lebih komprehensif, diperlukan analisis yang lebih mendalam dan menyeluruh. Berdasarkan visualisasi ini, dapat menyimpulkan bahwa baik usia maupun tingkat glukosa rata-rata merupakan faktor risiko yang signifikan untuk terjadinya stroke.

### GLUCOSE vs BMI dengan Stroke
"""

plt.figure(figsize=(8,8))
sns.set_style("darkgrid")
sns.scatterplot(data = data, x = 'avg_glucose_level', y = 'bmi', hue='stroke')
plt.show()

"""Grafik scatterplot diatas memberikan gambaran awal yang menarik tentang hubungan antara berat badan, tingkat glukosa, dan risiko stroke. Namun, untuk mendapatkan pemahaman yang lebih komprehensif, diperlukan analisis yang lebih mendalam dan menyeluruh. Tingkat glukosa rata-rata dan BMI merupakan faktor risiko yang perlu diperhatikan terkait dengan risiko stroke. Individu dengan kombinasi kedua faktor ini cenderung memiliki risiko stroke yang lebih tinggi.

### AGE vs BMI dengan Stroke
"""

plt.figure(figsize=(8,8))
sns.set_style("darkgrid")
sns.scatterplot(data = data, x = 'age', y = 'bmi', hue='stroke')
plt.show()

"""Grafik scatterplot diatas memberikan gambaran awal yang menarik tentang hubungan antara berat badan, umur, dan risiko stroke. Namun, untuk mendapatkan pemahaman yang lebih komprehensif, diperlukan analisis yang lebih mendalam dan menyeluruh. Semakin tua usia seseorang, semakin tinggi kemungkinan mereka mengalami stroke. Individu dengan BMI yang lebih tinggi cenderung memiliki risiko stroke yang lebih tinggi.

### PERBANDINGAN Gender dengan Stroke
"""

sns.countplot(x='stroke',hue='gender', data=data)
plt.show()

"""gambar diatas merupakan grafik perbandingan dari penderita stroke berdasarkan jenis kelaminnya.

### PERBANDINGAN Umur dengan Stroke
"""

data.plot(kind='scatter',x='stroke',y='age')
plt.show()

"""gambar diatas merupakan grafik perbandingan dari penderita stroke berdasarkan umurnya.

### PERBANDINGAN Umur dengan Tipe Pekerjaan
"""

plt.figure(figsize=(10, 6))
plt.scatter(data['age'], data['work_type'])

"""gambar diatas merupakan grafik perbandingan dari umur berdasarkan jenis pekerjaanya

### PERBANDINGAN Tipe Pekerjaan dengan Penyakit Jantung
"""

sns.countplot(x = 'work_type',hue='heart_disease' ,data=data)

"""gambar diatas merupakan grafik perbandingan dari tipe pekerjaan dengan penyakit jantung

### PERBANDINGAN Penyakit Jantung dengan Umur
"""

sns.barplot(x='heart_disease',y='age', hue='stroke' ,data=data)

"""gambar diatas merupakan grafik perbandingan dari penderita penyakit jantung berdasarkan umurnya.

### PAIR PLOT KESELURUHAN
"""

fig = plt.figure(figsize=(10,10))
sns.pairplot(data)
plt.show()

"""gambar diatas merupakan pair plot secara keseluruhan dari kolom-kolom yang terdapat pada dataset yang digunakan pada proyek ini.

# DATA PREPARATION (PRE-PROCESSING)
"""

data.isnull().sum()

"""tabel diatas menampilkan informasi data yang kosong pada dataset yang digunakan, dan tertera pada tabel diatas tidak ada data yang kosong."""

x = data.iloc[:, 1:-1].values
y = data.iloc[:, -1].values

x

"""Pemilahan Fitur (X) dan Label (Y) Dataset dipisahkan menjadi fitur independen x (dari kolom kedua hingga sebelum kolom terakhir) dan target label y (kolom terakhir). Hal ini dilakukan dengan menggunakan iloc dari pandas. Proses ini adalah langkah awal untuk membangun model machine learning di mana fitur digunakan untuk memprediksi label.

## ENCODING

### ENCODING KATEGORIKAL
"""

ct = ColumnTransformer(transformers= [('encoder', OneHotEncoder(), [0,5,9])], remainder= 'passthrough')
x = np.array(ct.fit_transform(x))

x

"""Encoding Kategorikal (One-Hot Encoding) Untuk mengonversi fitur kategorikal menjadi bentuk numerik yang dapat diproses oleh algoritma machine learning, digunakan One-Hot Encoding. Kolom 0, 5, dan 9 yang berisi data kategorikal diterjemahkan menjadi representasi biner menggunakan ColumnTransformer dengan OneHotEncoder. Kolom lainnya tetap diproses tanpa perubahan (remainder='passthrough).

### ENCODING LABEL
"""

le = LabelEncoder()
x[:, 15] = le.fit_transform(x[:, 15])
x[:, 16] = le.fit_transform(x[:, 16])

x

print('Shape of X: ', x.shape)
print('Shape of Y: ', y.shape)

"""Encoding Label (Label Encoding): Beberapa kolom spesifik diubah menjadi representasi numerik diskrit menggunakan Label Encoding. Ini dilakukan dengan LabelEncoder dari sklearn. Langkah ini berguna untuk kategori yang hanya memiliki dua atau sedikit label unik, seperti "Yes/No".

## SPLITING DATASET
"""

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size= 0.2, random_state= 0)

print("Number transactions x_train dataset: ", x_train.shape)
print("Number transactions y_train dataset: ", y_train.shape)
print("Number transactions x_test dataset: ", x_test.shape)
print("Number transactions y_test dataset: ", y_test.shape)

"""Train Test Split menggunakan library sklearn.model_selection untuk membagi dataset menjadi data latih dan data uji dengan pembagian sebesar 20:80 dan random state sebesar 0. Semua proses ini diperlukan dalam rangka membuat model yang baik.

## FETAURE SCALING
"""

sc = StandardScaler()
x_train = sc.fit_transform(x_train)
x_test = sc.transform(x_test)

"""Feature scaling merupakan proses untuk menormalkan data agar nilai-nilai fitur berada dalam skala yang sama, sehingga algoritma machine learning dapat bekerja lebih optimal. Dalam kode di atas, digunakan StandardScaler untuk melakukan feature scaling. StandardScaler menstandarkan data dengan cara mengurangi nilai rata-rata (mean) dan membaginya dengan standar deviasi (standard deviation) untuk setiap fitur. Proses ini dilakukan dengan memanggil metode fit_transform pada data training (x_train) untuk menghitung parameter (mean dan standard deviation) serta mentransformasikan data. Sementara itu, data testing (x_test) hanya ditransformasikan menggunakan parameter yang sama dengan data training melalui metode transform, agar tetap konsisten dan menghindari kebocoran data.

## PERBAIKAN VALUE YANG TIDAK BALANCE DENGAN SMOTE
"""

print("Before OverSampling, counts of label '1': {}".format(sum(y_train==1)))
print("Before OverSampling, counts of label '0': {} \n".format(sum(y_train==0)))

sm = SMOTE(random_state=2)
x_train_res, y_train_res = sm.fit_resample(x_train, y_train.ravel())

print('After OverSampling, the shape of train_X: {}'.format(x_train_res.shape))
print('After OverSampling, the shape of train_y: {} \n'.format(y_train_res.shape))

print("After OverSampling, counts of label '1': {}".format(sum(y_train_res==1)))
print("After OverSampling, counts of label '0': {}".format(sum(y_train_res==0)))

"""SMOTE merupakan teknik untuk menangani data yang tidak seimbang dengan cara membuat sampel sintetis dari kelas minoritas, sehingga distribusi kelas menjadi lebih seimbang. Dalam kode ini, sebelum menggunakan SMOTE, ditampilkan jumlah data untuk masing-masing label pada data training (y_train). Setelah itu, SMOTE diterapkan menggunakan fit_resample untuk membuat data baru berdasarkan fitur x_train dan label y_train. Proses ini menghasilkan dataset baru (x_train_res dan y_train_res) dengan jumlah data yang lebih seimbang. Setelah oversampling, ditampilkan bentuk (shape) dari dataset yang baru serta jumlah data untuk masing-masing label, menunjukkan bahwa kedua kelas kini memiliki jumlah data yang sama. Hal ini membantu meningkatkan performa model dalam mempelajari pola dari kelas minoritas.

# MODEL ML
"""

models = []
models.append(['Logistic Regreesion', LogisticRegression(random_state=0)])
models.append(['SVM', SVC(random_state=0)])
models.append(['KNeighbors', KNeighborsClassifier()])
models.append(['GaussianNB', GaussianNB()])
models.append(['BernoulliNB', BernoulliNB()])
models.append(['Decision Tree', DecisionTreeClassifier(random_state=0)])
models.append(['Random Forest', RandomForestClassifier(random_state=0)])
models.append(['XGBoost', XGBClassifier(eval_metric= 'error')])

"""Kode di atas membuat daftar berisi beberapa model machine learning dengan nama dan objek modelnya, yang akan digunakan untuk klasifikasi. Daftar tersebut bernama models, dan setiap model ditambahkan sebagai pasangan nama model (sebagai string) dan instance dari model itu sendiri. Model yang digunakan meliputi Logistic Regression, Support Vector Machine (SVM), K-Nearest Neighbors (KNeighbors), Gaussian Naive Bayes (GaussianNB), Bernoulli Naive Bayes (BernoulliNB), Decision Tree, Random Forest, dan XGBoost. Beberapa model disesuaikan dengan parameter tertentu, seperti random_state=0 untuk memastikan hasil yang konsisten dengan set seed untuk randomisasi. Dalam XGBoost, parameter eval_metric='error' digunakan untuk menentukan metrik evaluasi yang akan dipakai selama pelatihan. Daftar ini memungkinkan iterasi melalui berbagai algoritma untuk membandingkan performa mereka pada tugas klasifikasi tertentu."""

lst_1= []

for m in range(len(models)):
    lst_2= []
    model = models[m][1]
    model.fit(x_train_res, y_train_res)
    y_pred = model.predict(x_test)
    cm = confusion_matrix(y_test, y_pred)  #Confusion Matrix
    accuracies = cross_val_score(estimator = model, X = x_train_res, y = y_train_res, cv = 10)   #K-Fold Validation
    roc = roc_auc_score(y_test, y_pred)  #ROC AUC Score
    precision = precision_score(y_test, y_pred)  #Precision Score
    recall = recall_score(y_test, y_pred)  #Recall Score
    f1 = f1_score(y_test, y_pred)  #F1 Score
    print(models[m][0],':')
    print(cm)
    print('Accuracy Score: ',accuracy_score(y_test, y_pred))
    print("K-Fold Validation Mean Accuracy: {:.2f} %".format(accuracies.mean()*100))
    print("Standard Deviation: {:.2f} %".format(accuracies.std()*100))
    print('ROC AUC Score: {:.2f}'.format(roc))
    print('Precision: {:.2f}'.format(precision))
    print('Recall: {:.2f}'.format(recall))
    print('F1: {:.2f}'.format(f1))
    print('-----------------------------------')
    print('-----------------------------------')
    lst_2.append(models[m][0])
    lst_2.append((accuracy_score(y_test, y_pred))*100)
    lst_2.append(accuracies.mean()*100)
    lst_2.append(accuracies.std()*100)
    lst_2.append(roc)
    lst_2.append(precision)
    lst_2.append(recall)
    lst_2.append(f1)
    lst_1.append(lst_2)

"""
Kode diatas melakukan training dan evaluasi kinerja beberapa model machine learning dengan menghitung berbagai metrik evaluasi. Setiap model dilatih menggunakan data yang telah di-resample dengan SMOTE (x_train_res dan y_train_res) dan diuji pada data testing (x_test dan y_test). Prediksi model dievaluasi menggunakan confusion matrix, akurasi, validasi silang (mean dan standar deviasi), ROC AUC score, precision, recall, dan F1 score. Hasil evaluasi dicetak untuk setiap model, termasuk metrik utama dan confusion matrix. Selain itu, semua metrik disimpan dalam list terpisah (lst_2), yang kemudian ditambahkan ke list utama (lst_1), memungkinkan perbandingan hasil antar-model."""

df = pd.DataFrame(lst_1, columns= ['Model', 'Accuracy', 'K-Fold Mean Accuracy', 'Std. Deviation', 'ROC AUC', 'Precision', 'Recall', 'F1'])

df.sort_values(by= ['Accuracy', 'K-Fold Mean Accuracy'], inplace= True, ascending= False)

df

"""Gambar tabel diatas merupakan hasil dari pengurutan evaluasi yang dilakukan, dapat dilihat bahwa XGBoost merupakan model yang mendapat akurasi tertinggi daripada model yang lainnya.

## TUNING MODEL HYPERPARAMETER
"""

grid_models = [
    # Logistic Regression
    (LogisticRegression(), [
        {'C': [0.01, 0.1, 0.25, 0.5, 0.75, 1, 10],
         'penalty': ['l1', 'l2', 'elasticnet', 'none'],
         'solver': ['liblinear', 'saga'],
         'random_state': [0]}
    ]),

    # K-Nearest Neighbors
    (KNeighborsClassifier(), [
        {'n_neighbors': [3, 5, 7, 8, 10, 15],
         'metric': ['euclidean', 'manhattan', 'chebyshev', 'minkowski'],
         'weights': ['uniform', 'distance'],
         'p': [1, 2]}  # p=1 for Manhattan, p=2 for Euclidean
    ]),

    # Support Vector Machine
    (SVC(), [
        {'C': [0.01, 0.1, 0.25, 0.5, 0.75, 1],
         'kernel': ['linear', 'poly', 'rbf', 'sigmoid'],
         'degree': [2, 3, 4],  # For polynomial kernel
         'gamma': ['scale', 'auto'],
         'random_state': [0]}
    ]),

    # Gaussian Naive Bayes
    (GaussianNB(), [
        {'var_smoothing': [1e-09, 1e-08, 1e-07, 1e-06]}
    ]),

    # Bernoulli Naive Bayes
    (BernoulliNB(), [
        {'alpha': [0.1, 0.25, 0.5, 0.75, 1, 2],
         'binarize': [0.0, 0.5, 1.0]}  # Threshold for binarization
    ]),

    # Decision Tree
    (DecisionTreeClassifier(), [
        {'criterion': ['gini', 'entropy', 'log_loss'],
         'splitter': ['best', 'random'],
         'max_depth': [None, 10, 20, 30],
         'min_samples_split': [2, 5, 10],
         'random_state': [0]}
    ]),

    # Random Forest
    (RandomForestClassifier(), [
        {'n_estimators': [50, 100, 150, 200],
         'criterion': ['gini', 'entropy'],
         'max_depth': [None, 10, 20],
         'min_samples_split': [2, 5, 10],
         'max_features': ['sqrt', 'log2'],
         'random_state': [0]}
    ]),

    # XGBoost
    (XGBClassifier(), [
        {'learning_rate': [0.01, 0.05, 0.1, 0.2],
         'max_depth': [3, 5, 7, 10],
         'n_estimators': [100, 150, 200],
         'subsample': [0.6, 0.8, 1.0],
         'colsample_bytree': [0.6, 0.8, 1.0],
         'eval_metric': ['error', 'logloss']}
    ])
]

"""Kode diatas merupakan hyperparameter dari masing-masing model yang akan dilakukan hyperparameter tuning menggunakan gridsearch."""

for i,j in grid_models:
    grid = GridSearchCV(estimator=i,param_grid = j, scoring = 'accuracy',cv = 10)
    grid.fit(x_train_res, y_train_res)
    best_accuracy = grid.best_score_
    best_param = grid.best_params_
    print('{}:\nBest Accuracy : {:.2f}%'.format(i,best_accuracy*100))
    print('Best Parameters : ',best_param)
    print('-------------------------')
    print('-------------------------')

"""kode dan hasil diatas merupakan hasil dari training model machine learning dengan menerapkan hyperparameter tuning yang sudah dideklarasikan sebelumnya menggunakan GridSearch. dapat dilihat pada hasil diatas terdapat metrik evaluasi berupa akurasi dan juga best parameter dari masing-masing modelnya.

## EVALUASI MODEL

### LOGISTIC REGRESSION
"""

classifier = LogisticRegression(C=0.01, penalty='l1', random_state=0, solver='liblinear')
classifier.fit(x_train_res, y_train_res)
y_pred = classifier.predict(x_test)
y_prob = classifier.predict_proba(x_test)[:,1]
cm = confusion_matrix(y_test, y_pred)

print(classification_report(y_test, y_pred))
print(f'ROC AUC score: {roc_auc_score(y_test, y_prob)}')
print('Accuracy Score: ',accuracy_score(y_test, y_pred))

# Visualizing Confusion Matrix
plt.figure(figsize = (8, 5))
sns.heatmap(cm, cmap = 'Blues', annot = True, fmt = 'd', linewidths = 5, cbar = False, annot_kws = {'fontsize': 15},
            yticklabels = ['No stroke', 'Stroke'], xticklabels = ['Predicted no stroke', 'Predicted stroke'])
plt.yticks(rotation = 0)
plt.show()

# Roc AUC Curve
false_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, y_prob)
roc_auc = auc(false_positive_rate, true_positive_rate)

sns.set_theme(style = 'white')
plt.figure(figsize = (8, 8))
plt.plot(false_positive_rate,true_positive_rate, color = '#b01717', label = 'AUC = %0.3f' % roc_auc)
plt.legend(loc = 'lower right')
plt.plot([0, 1], [0, 1], linestyle = '--', color = '#174ab0')
plt.axis('tight')
plt.ylabel('True Positive Rate')
plt.xlabel('False Positive Rate')
plt.legend()
plt.show()

"""Kode di atas melatih model Logistic Regression dengan regularisasi L1 (penalty='l1') dan parameter C=0.01 menggunakan data training yang telah di-resample (x_train_res, y_train_res). Model menghasilkan prediksi (y_pred) dan probabilitas prediksi untuk kelas positif (y_prob). Evaluasi model dilakukan dengan menghitung confusion matrix, ROC AUC score, dan berbagai metrik melalui classification_report. Hasil evaluasi divisualisasikan dalam dua grafik: heatmap confusion matrix untuk menggambarkan prediksi model terhadap data testing (y_test) dan kurva ROC untuk mengukur performa klasifikasi berdasarkan trade-off antara true positive rate dan false positive rate. Nilai AUC (area under curve) juga dihitung untuk menunjukkan kemampuan model dalam membedakan kelas positif dan negatif. Hasil menunjukan bahwa akurasi yang didapat oleh algoritma logistic regression adalah 0.75 atau 75%, dan juga pada gambar hasil diatas sudah tertera hasil dari metrik evaluasi lainnya seperti precision, recall f1-score dan nilai AUC.

### KNN
"""

#Fitting RandomForest Model
classifier = KNeighborsClassifier(metric= 'manhattan', n_neighbors= 3, p= 1, weights= 'distance')
classifier.fit(x_train_res, y_train_res)
y_pred = classifier.predict(x_test)
y_prob = classifier.predict_proba(x_test)[:,1]
cm = confusion_matrix(y_test, y_pred)

print(classification_report(y_test, y_pred))
print(f'ROC AUC score: {roc_auc_score(y_test, y_prob)}')
print('Accuracy Score: ',accuracy_score(y_test, y_pred))

# Visualizing Confusion Matrix
plt.figure(figsize = (8, 5))
sns.heatmap(cm, cmap = 'Blues', annot = True, fmt = 'd', linewidths = 5, cbar = False, annot_kws = {'fontsize': 15},
            yticklabels = ['No stroke', 'Stroke'], xticklabels = ['Predicted no stroke', 'Predicted stroke'])
plt.yticks(rotation = 0)
plt.show()

# Roc AUC Curve
false_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, y_prob)
roc_auc = auc(false_positive_rate, true_positive_rate)

sns.set_theme(style = 'white')
plt.figure(figsize = (8, 8))
plt.plot(false_positive_rate,true_positive_rate, color = '#b01717', label = 'AUC = %0.3f' % roc_auc)
plt.legend(loc = 'lower right')
plt.plot([0, 1], [0, 1], linestyle = '--', color = '#174ab0')
plt.axis('tight')
plt.ylabel('True Positive Rate')
plt.xlabel('False Positive Rate')
plt.legend()
plt.show()

"""Hasil menunjukan bahwa akurasi yang didapat oleh algoritma KNN adalah 0.87 atau 87%, dan juga pada gambar hasil diatas sudah tertera hasil dari metrik evaluasi lainnya seperti precision, recall f1-score dan nilai AUC.

### SVM
"""

#Fitting RandomForest Model
classifier = SVC(C= 1, degree= 2, gamma= 'scale', kernel= 'rbf', random_state= 0, probability=True)
classifier.fit(x_train_res, y_train_res)
y_pred = classifier.predict(x_test)
y_prob = classifier.predict_proba(x_test)[:,1]
cm = confusion_matrix(y_test, y_pred)

print(classification_report(y_test, y_pred))
print(f'ROC AUC score: {roc_auc_score(y_test, y_prob)}')
print('Accuracy Score: ',accuracy_score(y_test, y_pred))

# Visualizing Confusion Matrix
plt.figure(figsize = (8, 5))
sns.heatmap(cm, cmap = 'Blues', annot = True, fmt = 'd', linewidths = 5, cbar = False, annot_kws = {'fontsize': 15},
            yticklabels = ['No stroke', 'Stroke'], xticklabels = ['Predicted no stroke', 'Predicted stroke'])
plt.yticks(rotation = 0)
plt.show()

# Roc AUC Curve
false_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, y_prob)
roc_auc = auc(false_positive_rate, true_positive_rate)

sns.set_theme(style = 'white')
plt.figure(figsize = (8, 8))
plt.plot(false_positive_rate,true_positive_rate, color = '#b01717', label = 'AUC = %0.3f' % roc_auc)
plt.legend(loc = 'lower right')
plt.plot([0, 1], [0, 1], linestyle = '--', color = '#174ab0')
plt.axis('tight')
plt.ylabel('True Positive Rate')
plt.xlabel('False Positive Rate')
plt.legend()
plt.show()

"""Hasil menunjukan bahwa akurasi yang didapat oleh algoritma SVM adalah 0.80 atau 80%, dan juga pada gambar hasil diatas sudah tertera hasil dari metrik evaluasi lainnya seperti precision, recall f1-score dan nilai AUC.

### NAIVE BAYES (BERNOULLI)
"""

#Fitting RandomForest Model
classifier = BernoulliNB(alpha= 0.1, binarize= 0.5)
classifier.fit(x_train_res, y_train_res)
y_pred = classifier.predict(x_test)
y_prob = classifier.predict_proba(x_test)[:,1]
cm = confusion_matrix(y_test, y_pred)

print(classification_report(y_test, y_pred))
print(f'ROC AUC score: {roc_auc_score(y_test, y_prob)}')
print('Accuracy Score: ',accuracy_score(y_test, y_pred))

# Visualizing Confusion Matrix
plt.figure(figsize = (8, 5))
sns.heatmap(cm, cmap = 'Blues', annot = True, fmt = 'd', linewidths = 5, cbar = False, annot_kws = {'fontsize': 15},
            yticklabels = ['No stroke', 'Stroke'], xticklabels = ['Predicted no stroke', 'Predicted stroke'])
plt.yticks(rotation = 0)
plt.show()

# Roc AUC Curve
false_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, y_prob)
roc_auc = auc(false_positive_rate, true_positive_rate)

sns.set_theme(style = 'white')
plt.figure(figsize = (8, 8))
plt.plot(false_positive_rate,true_positive_rate, color = '#b01717', label = 'AUC = %0.3f' % roc_auc)
plt.legend(loc = 'lower right')
plt.plot([0, 1], [0, 1], linestyle = '--', color = '#174ab0')
plt.axis('tight')
plt.ylabel('True Positive Rate')
plt.xlabel('False Positive Rate')
plt.legend()
plt.show()

"""Hasil menunjukan bahwa akurasi yang didapat oleh algoritma Naive Bayes (Bernoulli) adalah 0.73 atau 73%, dan juga pada gambar hasil diatas sudah tertera hasil dari metrik evaluasi lainnya seperti precision, recall f1-score dan nilai AUC.

### NAIVE BAYES (GAUSSIAN)
"""

#Fitting RandomForest Model
classifier = GaussianNB(var_smoothing= 1e-06)
classifier.fit(x_train_res, y_train_res)
y_pred = classifier.predict(x_test)
y_prob = classifier.predict_proba(x_test)[:,1]
cm = confusion_matrix(y_test, y_pred)

print(classification_report(y_test, y_pred))
print(f'ROC AUC score: {roc_auc_score(y_test, y_prob)}')
print('Accuracy Score: ',accuracy_score(y_test, y_pred))

# Visualizing Confusion Matrix
plt.figure(figsize = (8, 5))
sns.heatmap(cm, cmap = 'Blues', annot = True, fmt = 'd', linewidths = 5, cbar = False, annot_kws = {'fontsize': 15},
            yticklabels = ['No stroke', 'Stroke'], xticklabels = ['Predicted no stroke', 'Predicted stroke'])
plt.yticks(rotation = 0)
plt.show()

# Roc AUC Curve
false_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, y_prob)
roc_auc = auc(false_positive_rate, true_positive_rate)

sns.set_theme(style = 'white')
plt.figure(figsize = (8, 8))
plt.plot(false_positive_rate,true_positive_rate, color = '#b01717', label = 'AUC = %0.3f' % roc_auc)
plt.legend(loc = 'lower right')
plt.plot([0, 1], [0, 1], linestyle = '--', color = '#174ab0')
plt.axis('tight')
plt.ylabel('True Positive Rate')
plt.xlabel('False Positive Rate')
plt.legend()
plt.show()

"""Hasil menunjukan bahwa akurasi yang didapat oleh algoritma Naive bayes (Gaussian) adalah 0.20 atau 20%, dan juga pada gambar hasil diatas sudah tertera hasil dari metrik evaluasi lainnya seperti precision, recall f1-score dan nilai AUC.

### DECISION TREE
"""

#Fitting RandomForest Model
classifier = DecisionTreeClassifier(criterion= 'entropy', max_depth= 30, min_samples_split= 2, random_state= 0, splitter= 'random')
classifier.fit(x_train_res, y_train_res)
y_pred = classifier.predict(x_test)
y_prob = classifier.predict_proba(x_test)[:,1]
cm = confusion_matrix(y_test, y_pred)

print(classification_report(y_test, y_pred))
print(f'ROC AUC score: {roc_auc_score(y_test, y_prob)}')
print('Accuracy Score: ',accuracy_score(y_test, y_pred))

# Visualizing Confusion Matrix
plt.figure(figsize = (8, 5))
sns.heatmap(cm, cmap = 'Blues', annot = True, fmt = 'd', linewidths = 5, cbar = False, annot_kws = {'fontsize': 15},
            yticklabels = ['No stroke', 'Stroke'], xticklabels = ['Predicted no stroke', 'Predicted stroke'])
plt.yticks(rotation = 0)
plt.show()

# Roc AUC Curve
false_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, y_prob)
roc_auc = auc(false_positive_rate, true_positive_rate)

sns.set_theme(style = 'white')
plt.figure(figsize = (8, 8))
plt.plot(false_positive_rate,true_positive_rate, color = '#b01717', label = 'AUC = %0.3f' % roc_auc)
plt.legend(loc = 'lower right')
plt.plot([0, 1], [0, 1], linestyle = '--', color = '#174ab0')
plt.axis('tight')
plt.ylabel('True Positive Rate')
plt.xlabel('False Positive Rate')
plt.legend()
plt.show()

"""Hasil menunjukan bahwa akurasi yang didapat oleh algoritma decision tree adalah 0.86 atau 86%, dan juga pada gambar hasil diatas sudah tertera hasil dari metrik evaluasi lainnya seperti precision, recall f1-score dan nilai AUC.

### RANDOM FOREST
"""

#Fitting RandomForest Model
classifier = RandomForestClassifier(criterion= 'gini', max_depth= None, max_features= 'sqrt', min_samples_split= 2, n_estimators= 100, random_state= 0)
classifier.fit(x_train_res, y_train_res)
y_pred = classifier.predict(x_test)
y_prob = classifier.predict_proba(x_test)[:,1]
cm = confusion_matrix(y_test, y_pred)

print(classification_report(y_test, y_pred))
print(f'ROC AUC score: {roc_auc_score(y_test, y_prob)}')
print('Accuracy Score: ',accuracy_score(y_test, y_pred))

# Visualizing Confusion Matrix
plt.figure(figsize = (8, 5))
sns.heatmap(cm, cmap = 'Blues', annot = True, fmt = 'd', linewidths = 5, cbar = False, annot_kws = {'fontsize': 15},
            yticklabels = ['No stroke', 'Stroke'], xticklabels = ['Predicted no stroke', 'Predicted stroke'])
plt.yticks(rotation = 0)
plt.show()

# Roc AUC Curve
false_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, y_prob)
roc_auc = auc(false_positive_rate, true_positive_rate)

sns.set_theme(style = 'white')
plt.figure(figsize = (8, 8))
plt.plot(false_positive_rate,true_positive_rate, color = '#b01717', label = 'AUC = %0.3f' % roc_auc)
plt.legend(loc = 'lower right')
plt.plot([0, 1], [0, 1], linestyle = '--', color = '#174ab0')
plt.axis('tight')
plt.ylabel('True Positive Rate')
plt.xlabel('False Positive Rate')
plt.legend()
plt.show()

"""Hasil menunjukan bahwa akurasi yang didapat oleh algoritma random forest adalah 0.91 atau 91%, dan juga pada gambar hasil diatas sudah tertera hasil dari metrik evaluasi lainnya seperti precision, recall f1-score dan nilai AUC.

### XGBOOST
"""

#Fitting XGBClassifier Model
classifier = XGBClassifier(eval_metric= 'error', learning_rate= 0.1)
classifier.fit(x_train_res, y_train_res)
y_pred = classifier.predict(x_test)
y_prob = classifier.predict_proba(x_test)[:,1]
cm = confusion_matrix(y_test, y_pred)

print(classification_report(y_test, y_pred))
print(f'ROC AUC score: {roc_auc_score(y_test, y_prob)}')
print('Accuracy Score: ',accuracy_score(y_test, y_pred))

# Visualizing Confusion Matrix
plt.figure(figsize = (8, 5))
sns.heatmap(cm, cmap = 'Blues', annot = True, fmt = 'd', linewidths = 5, cbar = False, annot_kws = {'fontsize': 15},
            yticklabels = ['No stroke', 'Stroke'], xticklabels = ['Predicted no stroke', 'Predicted stroke'])
plt.yticks(rotation = 0)
plt.show()

# Roc Curve
false_positive_rate, true_positive_rate, thresholds = roc_curve(y_test, y_prob)
roc_auc = auc(false_positive_rate, true_positive_rate)

sns.set_theme(style = 'white')
plt.figure(figsize = (8, 8))
plt.plot(false_positive_rate,true_positive_rate, color = '#b01717', label = 'AUC = %0.3f' % roc_auc)
plt.legend(loc = 'lower right')
plt.plot([0, 1], [0, 1], linestyle = '--', color = '#174ab0')
plt.axis('tight')
plt.ylabel('True Positive Rate')
plt.xlabel('False Positive Rate')

"""Hasil menunjukan bahwa akurasi yang didapat oleh algoritma XGBOOST adalah 0.90 atau 90%, dan juga pada gambar hasil diatas sudah tertera hasil dari metrik evaluasi lainnya seperti precision, recall f1-score dan nilai AUC.

# MODEL DL

## ANN
"""

# Define the custom Keras classifier
class KerasClassifierCustom(BaseEstimator, ClassifierMixin):
    def __init__(self, build_fn=None, batch_size=32, epochs=50, **kwargs):
        self.build_fn = build_fn
        self.batch_size = batch_size
        self.epochs = epochs
        self.kwargs = kwargs

    def fit(self, X, y):
        self.model = self.build_fn(**self.kwargs)
        self.model.fit(X, y, epochs=self.epochs, batch_size=self.batch_size, verbose=1)
        return self

    def predict(self, X):
        return self.model.predict(X).round()  # rounding for binary classification

"""Kode di atas mendefinisikan sebuah class KerasClassifierCustom yang mengimplementasikan BaseEstimator dan ClassifierMixin dari Scikit-learn, memungkinkan penggunaan model Keras sebagai classifier yang kompatibel dengan pipeline Scikit-learn. Class ini memerlukan fungsi pembangun model (build_fn), yang akan digunakan untuk membuat arsitektur model Keras. Parameter tambahan seperti ukuran batch (batch_size), jumlah epoch (epochs), dan argumen lainnya (kwargs) juga dapat ditentukan. Metode fit digunakan untuk melatih model Keras dengan data input (X dan y) menggunakan fungsi pembangun yang telah didefinisikan, sedangkan metode predict menghasilkan prediksi dengan membulatkan output model untuk klasifikasi biner. Class ini mempermudah integrasi model Keras dalam proses evaluasi atau pipeline yang memanfaatkan Scikit-learn."""

# Build the ANN model
def ann_classifier():
    ann = tf.keras.models.Sequential()
    ann.add(tf.keras.layers.Dense(units=8, kernel_regularizer=l2(0.01), bias_regularizer=l2(0.01), activation='relu'))
    ann.add(tf.keras.layers.Dense(units=8, kernel_regularizer=l2(0.01), bias_regularizer=l2(0.01), activation='relu'))
    ann.add(tf.keras.layers.Dropout(0.6))  # Now dropout is properly added to the model
    ann.add(tf.keras.layers.Dense(units=1, activation='sigmoid'))
    ann.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
    return ann

"""Fungsi ann_classifier membangun model Artificial Neural Network (ANN) menggunakan API Sequential dari TensorFlow Keras untuk klasifikasi biner. Model memiliki tiga lapisan: dua hidden layer dengan masing-masing 8 neuron yang menggunakan fungsi aktivasi ReLU dan regularisasi L2 untuk mencegah overfitting, serta satu dropout layer dengan rate 0.6 untuk meningkatkan generalisasi. Lapisan output memiliki 1 neuron dengan fungsi aktivasi sigmoid untuk menghasilkan probabilitas kelas. Model dikompilasi dengan optimizer Adam, fungsi loss binary crossentropy, dan metrik akurasi untuk evaluasi performa selama pelatihan."""

# Prepare the KerasClassifierCustom wrapper for cross-validation
ann = KerasClassifierCustom(build_fn=ann_classifier, batch_size=32, epochs=50)

# Perform 5-fold cross-validation
accuracies = cross_val_score(estimator=ann, X=x_train_res, y=y_train_res, cv=5)

"""proses training model ANN"""

# Checking the mean and standard deviation of the accuracies obtained
mean = accuracies.mean()
std_deviation = accuracies.std()
print("Accuracy: {:.2f} %".format(mean * 100))
print("Standard Deviation: {:.2f} %".format(std_deviation * 100))

"""Kode di atas menghitung rata-rata (mean) dan standar deviasi (std_deviation) dari nilai akurasi yang diperoleh selama evaluasi model, biasanya dari validasi silang atau iterasi tertentu. Nilai rata-rata (mean) menunjukkan performa rata-rata model, sementara standar deviasi (std_deviation) menggambarkan seberapa bervariasi akurasi antar-fold atau iterasi. Hasil ini kemudian dicetak dalam format persentase, memberikan gambaran tentang kestabilan dan keandalan model dalam klasifikasi.

## TUNING HYPERPARAMETER ANN
"""

# Define the Custom KerasClassifier class
class KerasClassifierCustom(BaseEstimator, ClassifierMixin):
    def __init__(self, build_fn, batch_size=32, epochs=50, optimizer='adam'):
        self.build_fn = build_fn
        self.batch_size = batch_size
        self.epochs = epochs
        self.optimizer = optimizer  # Add optimizer as a parameter
        self.model = None

    def fit(self, X, y):
        # Pass optimizer to the build_fn during model creation
        self.model = self.build_fn(optimizer=self.optimizer)
        self.model.fit(X, y, batch_size=self.batch_size, epochs=self.epochs, verbose=0)
        return self

    def predict(self, X):
        return (self.model.predict(X) > 0.5).astype(int)

    def score(self, X, y):
        return self.model.evaluate(X, y, verbose=0)[1]

"""
Kode diatas mendefinisikan class KerasClassifierCustom, yang merupakan implementasi custom dari BaseEstimator dan ClassifierMixin untuk mengintegrasikan model Keras ke dalam pipeline Scikit-learn. Class ini menerima fungsi pembangun model (build_fn), ukuran batch (batch_size), jumlah epoch (epochs), dan parameter tambahan seperti optimizer untuk fleksibilitas konfigurasi pelatihan. Pada metode fit, model dibuat menggunakan build_fn dengan parameter optimizer yang diteruskan, kemudian dilatih dengan data input (X dan y). Metode predict menghasilkan prediksi biner (0 atau 1) berdasarkan probabilitas yang dihasilkan model, sedangkan metode score mengembalikan akurasi model berdasarkan evaluasi terhadap data validasi (X dan y). Class ini memungkinkan integrasi model Keras ke dalam proses pelatihan, prediksi, dan evaluasi berbasis Scikit-learn dengan lebih mudah."""

# Building the ANN model
def ann_classifier(optimizer='adam'):
    ann = tf.keras.models.Sequential()
    ann.add(tf.keras.layers.Dense(units=8, kernel_regularizer=l2(0.01), bias_regularizer=l2(0.01), activation='relu'))
    ann.add(tf.keras.layers.Dense(units=8, kernel_regularizer=l2(0.01), bias_regularizer=l2(0.01), activation='relu'))
    ann.add(tf.keras.layers.Dropout(0.6))
    ann.add(tf.keras.layers.Dense(units=1, activation='sigmoid'))
    ann.compile(optimizer=optimizer, loss='binary_crossentropy', metrics=['accuracy'])
    return ann

"""Fungsi ann_classifier membangun model Artificial Neural Network (ANN) untuk klasifikasi biner dengan fleksibilitas dalam memilih optimizer. Model ini terdiri dari dua hidden layer, masing-masing memiliki 8 neuron dengan fungsi aktivasi ReLU dan regularisasi L2 pada bobot dan bias untuk mencegah overfitting. Sebuah dropout layer dengan rate 0.6 disisipkan untuk lebih meningkatkan generalisasi dengan mengurangi ketergantungan antar neuron. Lapisan output terdiri dari 1 neuron dengan fungsi aktivasi sigmoid untuk menghasilkan probabilitas kelas. Model dikompilasi menggunakan optimizer yang dapat disesuaikan melalui parameter fungsi (optimizer), dengan fungsi loss binary crossentropy dan metrik accuracy untuk mengevaluasi performa selama pelatihan."""

# Wrapping the model with KerasClassifierCustom
ann = KerasClassifierCustom(build_fn=ann_classifier, batch_size=32, epochs=50)

# Grid Search CV for hyperparameter tuning
parameters = {'batch_size': [25, 32],
              'epochs': [50, 100, 150],
              'optimizer': ['adam', 'rmsprop']}  # Now optimizer is a valid parameter

grid_search = GridSearchCV(estimator=ann, param_grid=parameters, scoring='accuracy', cv=5, n_jobs=-1)

# Fit the model with the training data
grid_search.fit(x_train_res, y_train_res)

"""proses training model dan penentuan hyperparameter tuning"""

best_parameters = grid_search.best_params_
print("Best Parameters:", best_parameters)

"""best parameter dari hasil training model

### EVALUASI MODEL SETELAH TUNING HYPERPARAMETER
"""

ann = tf.keras.models.Sequential()
ann.add(tf.keras.layers.Dense(units= 32, kernel_regularizer=l2(0.01), bias_regularizer=l2(0.01), activation='relu'))
ann.add(tf.keras.layers.Dense(units= 32, kernel_regularizer=l2(0.01), bias_regularizer=l2(0.01), activation='relu'))
tf.keras.layers.Dropout(0.6)
ann.add(tf.keras.layers.Dense(units= 1, activation='sigmoid'))
ann.compile(optimizer= 'adam', loss= 'binary_crossentropy', metrics= ['accuracy'])

ann_history = ann.fit(x_train_res, y_train_res, batch_size= 25, epochs= 150, validation_split= 0.2)

loss_train = ann_history.history['loss']
loss_val = ann_history.history['val_loss']
epochs = range(1,151)
plt.plot(epochs, loss_train, 'g', label='Training loss')
plt.plot(epochs, loss_val, 'b', label='validation loss')
plt.title('Training and Validation loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()
plt.show()

loss_train = ann_history.history['accuracy']
loss_val = ann_history.history['val_accuracy']
epochs = range(1,151)
plt.plot(epochs, loss_train, 'g', label='Training accuracy')
plt.plot(epochs, loss_val, 'b', label='validation accuracy')
plt.title('Training and Validation accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend()
plt.show()

# Calculate accuracy score
accuracy = accuracy_score(y_test, y_pred)
print('Accuracy: {:.2f} %'.format(accuracy * 100))

# Making the Confusion Matrix
cm = confusion_matrix(y_test, y_pred)
print('Confusion Matrix:\n',cm)

# Calculate the Accuracy
accuracy = accuracy_score(y_pred,y_test)
print('Accuracy: ',accuracy)

#Visualizing Confusion Matrix
plt.figure(figsize = (8, 5))
sns.heatmap(cm, cmap = 'Blues', annot = True, fmt = 'd', linewidths = 5, cbar = False, annot_kws = {'fontsize': 15},
            yticklabels = ['No stroke', 'Stroke'], xticklabels = ['Predicted no stroke', 'Predicted stroke'])
plt.yticks(rotation = 0)
plt.show()

"""Hasil dari evaluasi model setelah hyperparameter tuning ini mendapatkan akurasi 89.73% dan confusion matrix seperti gambar diatas ini.

## RNN
"""

# Define the custom Keras classifier
class KerasClassifierCustom(BaseEstimator, ClassifierMixin):
    def __init__(self, build_fn=None, batch_size=32, epochs=50, **kwargs):
        self.build_fn = build_fn
        self.batch_size = batch_size
        self.epochs = epochs
        self.kwargs = kwargs

    def fit(self, X, y):
        self.model = self.build_fn(**self.kwargs)
        self.model.fit(X, y, epochs=self.epochs, batch_size=self.batch_size, verbose=1)
        return self

    def predict(self, X):
        return self.model.predict(X).round()  # rounding for binary classification

"""Kode di atas mendefinisikan sebuah class KerasClassifierCustom yang mengimplementasikan BaseEstimator dan ClassifierMixin dari Scikit-learn, memungkinkan penggunaan model Keras sebagai classifier yang kompatibel dengan pipeline Scikit-learn."""

# Build the RNN model (SimpleRNN)
def rnn_classifier():
    rnn = tf.keras.models.Sequential()
    rnn.add(SimpleRNN(units=64, activation='relu', input_shape=(x_train_res.shape[1], x_train_res.shape[2]), return_sequences=True))
    rnn.add(Dropout(0.6))  # Add dropout for regularization
    rnn.add(SimpleRNN(units=32, activation='relu'))
    rnn.add(Dropout(0.6))  # Another dropout layer
    rnn.add(tf.keras.layers.Dense(units=1, activation='sigmoid'))  # Output layer for binary classification
    rnn.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
    return rnn

"""Fungsi rnn_classifier membangun model Recurrent Neural Network (RNN) menggunakan SimpleRNN untuk klasifikasi biner. Model ini dimulai dengan lapisan SimpleRNN pertama yang memiliki 64 unit dengan fungsi aktivasi ReLU dan parameter return_sequences=True untuk mengirimkan urutan output ke lapisan berikutnya. Dropout layer dengan rate 0.6 ditambahkan setelah lapisan RNN pertama untuk mencegah overfitting. Lapisan RNN kedua memiliki 32 unit dan juga menggunakan aktivasi ReLU, diikuti oleh dropout layer kedua untuk lebih mengurangi overfitting. Lapisan output terdiri dari 1 neuron dengan aktivasi sigmoid untuk menghasilkan probabilitas kelas. Model dikompilasi menggunakan optimizer Adam, binary crossentropy sebagai fungsi loss untuk klasifikasi biner, dan accuracy sebagai metrik evaluasi performa. Model ini siap untuk digunakan dalam pelatihan dan prediksi untuk klasifikasi biner."""

# Prepare the KerasClassifierCustom wrapper for cross-validation
rnn = KerasClassifierCustom(build_fn=rnn_classifier, batch_size=32, epochs=50)

# Perform 5-fold cross-validation
accuracies = cross_val_score(estimator=rnn, X=x_train_res, y=y_train_res, cv=5)

"""proses training model RNN"""

# Checking the mean and standard deviation of the accuracies obtained
mean = accuracies.mean()
std_deviation = accuracies.std()
print("Accuracy: {:.2f} %".format(mean * 100))
print("Standard Deviation: {:.2f} %".format(std_deviation * 100))

"""Kode di atas menghitung rata-rata (mean) dan standar deviasi (std_deviation) dari nilai akurasi yang diperoleh selama evaluasi model, biasanya dari validasi silang atau iterasi tertentu. Nilai rata-rata (mean) menunjukkan performa rata-rata model, sementara standar deviasi (std_deviation) menggambarkan seberapa bervariasi akurasi antar-fold atau iterasi. Hasil ini kemudian dicetak dalam format persentase, memberikan gambaran tentang kestabilan dan keandalan model dalam klasifikasi.

## TUNING HYPERPARAMETER
"""

class KerasClassifierCustom(BaseEstimator, ClassifierMixin):
    def __init__(self, build_fn, batch_size=32, epochs=50, optimizer='adam'):
        self.build_fn = build_fn
        self.batch_size = batch_size
        self.epochs = epochs
        self.optimizer = optimizer
        self.model = None

    def fit(self, X, y):
        # Build the model with the current parameters
        self.model = self.build_fn(optimizer=self.optimizer)
        self.model.fit(
            X, y,
            batch_size=self.batch_size,
            epochs=self.epochs,
            validation_split=0.2,  # Add validation split
            verbose=0
        )
        return self

    def predict(self, X):
        # Return predictions as binary class labels
        return (self.model.predict(X) > 0.5).astype(int)

    def score(self, X, y):
        # Return the accuracy score
        return self.model.evaluate(X, y, verbose=0)[1]

    def get_params(self, deep=True):
        # Expose parameters for GridSearchCV
        return {
            "build_fn": self.build_fn,
            "batch_size": self.batch_size,
            "epochs": self.epochs,
            "optimizer": self.optimizer,
        }

    def set_params(self, **params):
        # Update parameters for GridSearchCV
        for param, value in params.items():
            setattr(self, param, value)
        return self

"""Kelas KerasClassifierCustom adalah pembungkus kustom untuk model Keras yang dirancang agar dapat terintegrasi dengan ekosistem scikit-learn, memungkinkan model Keras digunakan dengan alat seperti GridSearchCV dan cross_val_score. Kelas ini mewarisi dari BaseEstimator dan ClassifierMixin, menjadikannya kompatibel dengan antarmuka scikit-learn. Kelas ini menyediakan metode untuk melatih model (fit), memprediksi label kelas (predict), dan mengevaluasi kinerja model (score). Kelas ini juga mencakup metode get_params dan set_params untuk mengekspos dan memperbarui parameter model, memungkinkan pencarian hiperparameter. Pembungkus ini memungkinkan model Keras terintegrasi dengan lancar ke dalam alur kerja pemilihan dan evaluasi model scikit-learn."""

# Define the RNN model
def build_rnn(optimizer='adam'):
    model = tf.keras.models.Sequential()
    model.add(SimpleRNN(units=32, activation='relu', input_shape=(x_train_res.shape[1], x_train_res.shape[2]), return_sequences=True))
    model.add(Dropout(rate=0.5))
    model.add(SimpleRNN(units=16, activation='relu'))
    model.add(Dropout(rate=0.5))
    model.add(Dense(units=1, activation='sigmoid'))
    model.compile(optimizer=optimizer, loss='binary_crossentropy', metrics=['accuracy'])
    return model

"""Fungsi build_rnn mendefinisikan sebuah model Recurrent Neural Network (RNN) menggunakan Keras. Model ini terdiri dari dua lapisan SimpleRNN, masing-masing dengan 32 dan 16 unit neuron, yang dilengkapi dengan fungsi aktivasi ReLU untuk menangkap pola temporal dalam data. Setiap lapisan RNN diikuti oleh lapisan Dropout dengan tingkat 0.5 untuk mencegah overfitting dengan menghilangkan 50% dari neuron secara acak selama pelatihan. Model ini berakhir dengan lapisan Dense yang menghasilkan output biner menggunakan fungsi aktivasi sigmoid, yang cocok untuk klasifikasi biner. Model ini disusun menggunakan optimizer yang ditentukan (default: Adam), dengan fungsi kerugian binary_crossentropy dan metrik accuracy. Model ini siap untuk melatih data urutan seperti teks atau seri waktu."""

# Initialize the custom Keras classifier
rnn_custom = KerasClassifierCustom(build_fn=build_rnn)

# Define the hyperparameters to tune
parameters = {
    'batch_size': [16, 32],
    'epochs': [30, 50],
    'build_fn__optimizer': ['adam', 'rmsprop'],
    'build_fn__dropout_rate': [0.3, 0.6],
    'build_fn__units': [32, 64]
}

"""penentuan hyperparameter tuning yang akan digunakan pada model RNN"""

# Perform GridSearchCV
grid_search = GridSearchCV(estimator=rnn_custom, param_grid=parameters, cv=3, scoring='accuracy', verbose=1)
grid_search.fit(x_train_res, y_train_res)

"""proses training model dengan menerapkan gridsearch untuk hyperparameter tuning."""

# Best parameters and accuracy
print("Best Parameters:", grid_search.best_params_)

"""parameter terbaik dari hasil training model menggunakan gridsearch

### EVALUASI MODEL SETELAH TUNING
"""

# Define the RNN model
rnn = tf.keras.models.Sequential()
rnn.add(tf.keras.layers.SimpleRNN(units=32, activation='relu', input_shape=(x_train_res.shape[1], x_train_res.shape[2]), return_sequences=True))
rnn.add(tf.keras.layers.Dropout(0.6))
rnn.add(tf.keras.layers.SimpleRNN(units=16, activation='relu'))
rnn.add(tf.keras.layers.Dropout(0.6))
rnn.add(tf.keras.layers.Dense(units=1, activation='sigmoid'))
rnn.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Train the model
rnn_history = rnn.fit(x_train_res, y_train_res, batch_size=25, epochs=150, validation_split=0.2)

# Evaluate the training and validation loss
loss_train = rnn_history.history['loss']
loss_val = rnn_history.history['val_loss']
epochs = range(1, 151)

plt.plot(epochs, loss_train, 'g', label='Training loss')
plt.plot(epochs, loss_val, 'b', label='Validation loss')
plt.title('Training and Validation Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()
plt.show()

# Evaluate the training and validation accuracy
acc_train = rnn_history.history['accuracy']
acc_val = rnn_history.history['val_accuracy']

plt.plot(epochs, acc_train, 'g', label='Training accuracy')
plt.plot(epochs, acc_val, 'b', label='Validation accuracy')
plt.title('Training and Validation Accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend()
plt.show()

print("Shape of x_train_res:", x_train_res.shape)
print("Shape of x_test:", x_test.shape)

# Predict on test set
y_pred = rnn.predict(x_test)
y_pred = (y_pred > 0.5).astype(int)  # Convert probabilities to binary predictions

# Calculate accuracy score
accuracy = accuracy_score(y_test, y_pred)
print('Accuracy: {:.2f} %'.format(accuracy * 100))

# Confusion Matrix
cm = confusion_matrix(y_test, y_pred)
print('Confusion Matrix:\n', cm)

# Visualizing the Confusion Matrix
plt.figure(figsize=(8, 5))
sns.heatmap(cm, cmap='Blues', annot=True, fmt='d', linewidths=5, cbar=False, annot_kws={'fontsize': 15},
            yticklabels=['No Stroke', 'Stroke'], xticklabels=['Predicted No Stroke', 'Predicted Stroke'])
plt.yticks(rotation=0)
plt.title('Confusion Matrix')
plt.show()

"""Hasil dari evaluasi model setelah hyperparameter tuning ini mendapatkan akurasi 39.04% dan confusion matrix seperti gambar diatas ini.

## LSTM
"""

# Define the custom Keras classifier
class KerasClassifierCustom(BaseEstimator, ClassifierMixin):
    def __init__(self, build_fn=None, batch_size=32, epochs=50, **kwargs):
        self.build_fn = build_fn
        self.batch_size = batch_size
        self.epochs = epochs
        self.kwargs = kwargs

    def fit(self, X, y):
        self.model = self.build_fn(**self.kwargs)
        self.model.fit(X, y, epochs=self.epochs, batch_size=self.batch_size, verbose=1)
        return self

    def predict(self, X):
        return self.model.predict(X).round()  # rounding for binary classification

"""Kode di atas mendefinisikan sebuah kelas KerasClassifierCustom yang digunakan untuk membungkus model Keras agar dapat digunakan dalam skenario pembelajaran mesin seperti dengan Scikit-Learn. Kelas ini mewarisi BaseEstimator dan ClassifierMixin, memungkinkan penggunaan objek ini dengan teknik seperti GridSearchCV. Kelas ini memiliki metode __init__ untuk menginisialisasi parameter seperti build_fn (fungsi untuk membangun model), batch_size, epochs, dan parameter tambahan lainnya yang diteruskan dalam kwargs. Metode fit digunakan untuk melatih model dengan data X dan target y, menggunakan fungsi pembangun model yang diteruskan dalam build_fn dan parameter lainnya. Metode predict digunakan untuk menghasilkan prediksi dari model, dengan pembulatan hasil prediksi menjadi nilai biner (0 atau 1) untuk klasifikasi biner."""

def lstm_classifier():
    lstm = tf.keras.models.Sequential()
    lstm.add(tf.keras.layers.LSTM(units=64, activation='relu', input_shape=(x_train_res.shape[1], x_train_res.shape[2]), return_sequences=True))
    lstm.add(Dropout(0.6))  # Add dropout for regularization
    lstm.add(tf.keras.layers.LSTM(units=32, activation='relu'))
    lstm.add(Dropout(0.6))  # Another dropout layer
    lstm.add(tf.keras.layers.Dense(units=1, activation='sigmoid'))
    lstm.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
    return lstm

"""Fungsi lstm_classifier() di atas mendefinisikan sebuah model Long Short-Term Memory (LSTM) untuk klasifikasi biner. Model ini menggunakan arsitektur jaringan berurutan (Sequential) dari TensorFlow Keras. Pertama, lapisan LSTM dengan 64 unit ditambahkan, menggunakan fungsi aktivasi ReLU, dan mengatur parameter return_sequences=True untuk mengirimkan urutan output ke lapisan berikutnya. Setelah itu, lapisan dropout dengan tingkat 0.6 ditambahkan untuk mencegah overfitting dengan mematikan sejumlah unit secara acak selama pelatihan. Selanjutnya, lapisan LSTM lain dengan 32 unit ditambahkan, diikuti oleh lapisan dropout lainnya. Model ini diakhiri dengan lapisan output yang memiliki satu unit dan fungsi aktivasi sigmoid untuk menghasilkan prediksi biner. Model dikompilasi menggunakan optimasi Adam dan fungsi loss binary_crossentropy, dengan metrik akurasi yang digunakan untuk evaluasi kinerja model."""

# Prepare the KerasClassifierCustom wrapper for cross-validation
lstm = KerasClassifierCustom(build_fn=lstm_classifier, batch_size=32, epochs=50)

n_features = x_train_res.shape[1]
x_train_res = x_train_res.reshape((x_train_res.shape[0], 1, n_features))
y_train_res = np.array(y_train_res)

# Perform 5-fold cross-validation
accuracies = cross_val_score(estimator=lstm, X=x_train_res, y=y_train_res, cv=5)

"""proses training model LSTM"""

# Checking the mean and standard deviation of the accuracies obtained
mean = accuracies.mean()
std_deviation = accuracies.std()
print("Accuracy: {:.2f} %".format(mean * 100))
print("Standard Deviation: {:.2f} %".format(std_deviation * 100))

"""Kode di atas menghitung rata-rata (mean) dan standar deviasi (std_deviation) dari nilai akurasi yang diperoleh selama evaluasi model, biasanya dari validasi silang atau iterasi tertentu. Nilai rata-rata (mean) menunjukkan performa rata-rata model, sementara standar deviasi (std_deviation) menggambarkan seberapa bervariasi akurasi antar-fold atau iterasi. Hasil ini kemudian dicetak dalam format persentase, memberikan gambaran tentang kestabilan dan keandalan model dalam klasifikasi.

## TUNING HYPERPARAMETER
"""

class KerasClassifierCustom(BaseEstimator, ClassifierMixin):
    def __init__(self, build_fn, batch_size=32, epochs=50, optimizer='adam'):
        self.build_fn = build_fn
        self.batch_size = batch_size
        self.epochs = epochs
        self.optimizer = optimizer
        self.model = None

    def fit(self, X, y):
        # Build the model with the current parameters
        self.model = self.build_fn(optimizer=self.optimizer)
        self.model.fit(
            X, y,
            batch_size=self.batch_size,
            epochs=self.epochs,
            validation_split=0.2,  # Add validation split
            verbose=0
        )
        return self

    def predict(self, X):
        # Return predictions as binary class labels
        return (self.model.predict(X) > 0.5).astype(int)

    def score(self, X, y):
        # Return the accuracy score
        return self.model.evaluate(X, y, verbose=0)[1]

    def get_params(self, deep=True):
        # Expose parameters for GridSearchCV
        return {
            "build_fn": self.build_fn,
            "batch_size": self.batch_size,
            "epochs": self.epochs,
            "optimizer": self.optimizer,
        }

    def set_params(self, **params):
        # Update parameters for GridSearchCV
        for param, value in params.items():
            setattr(self, param, value)
        return self

"""
Kelas KerasClassifierCustom adalah implementasi custom classifier untuk model Keras, yang memungkinkan pengaturan parameter model secara dinamis dan kompatibel dengan teknik pencarian hyperparameter seperti GridSearchCV dari scikit-learn. Di dalamnya, fungsi __init__ menginisialisasi model dengan parameter batch_size, epochs, dan optimizer yang dapat disesuaikan. Fungsi fit digunakan untuk melatih model dengan data X dan y, serta memungkinkan pembagian data untuk validasi dengan parameter validation_split. Fungsi predict mengembalikan prediksi kelas biner (0 atau 1) berdasarkan output sigmoid dari model. Fungsi score mengembalikan skor akurasi model pada data uji. Fungsi get_params dan set_params memungkinkan akses dan pembaruan parameter model untuk tujuan pencarian hyperparameter dengan GridSearchCV, yang membantu dalam eksplorasi konfigurasi terbaik untuk model."""

# Define the LSTM model
def build_lstm(optimizer='adam'):
    model = tf.keras.models.Sequential()
    model.add(tf.keras.layers.LSTM(units=32, activation='relu', input_shape=(x_train_res.shape[1], x_train_res.shape[2]), return_sequences=True))
    model.add(Dropout(rate=0.5))
    model.add(tf.keras.layers.LSTM(units=16, activation='relu'))
    model.add(Dropout(rate=0.5))
    model.add(Dense(units=1, activation='sigmoid'))
    model.compile(optimizer=optimizer, loss='binary_crossentropy', metrics=['accuracy'])
    return model

"""
Fungsi build_lstm mendefinisikan model Long Short-Term Memory (LSTM) untuk tugas klasifikasi biner menggunakan Keras. Model ini dimulai dengan lapisan LSTM pertama yang memiliki 32 unit dan fungsi aktivasi ReLU, yang menerima input dengan bentuk (x_train_res.shape[1], x_train_res.shape[2]) dan mengembalikan urutan (sequence) sebagai output. Setelah itu, ditambahkan lapisan Dropout dengan tingkat 0,5 untuk mengurangi risiko overfitting. Lapisan LSTM kedua, dengan 16 unit dan aktivasi ReLU, kemudian memproses output dari lapisan pertama, diikuti oleh lapisan Dropout lain untuk mengurangi overfitting. Lapisan output menggunakan satu unit dengan aktivasi sigmoid untuk menghasilkan prediksi klasifikasi biner. Model ini dikompilasi menggunakan optimizer Adam dan loss function binary crossentropy untuk menghitung kerugian pada klasifikasi biner."""

# Initialize the custom Keras classifier
lstm_custom = KerasClassifierCustom(build_fn=build_lstm)

# Define the hyperparameters to tune
parameters = {
    'batch_size': [16, 32],
    'epochs': [30, 50],
    'build_fn__optimizer': ['adam', 'rmsprop'],
    'build_fn__dropout_rate': [0.3, 0.6],
    'build_fn__units': [32, 64]
}

"""penentuan hyperparameter pada model LSTM"""

# Perform GridSearchCV
grid_search = GridSearchCV(estimator=lstm_custom, param_grid=parameters, cv=3, scoring='accuracy', verbose=1)
grid_search.fit(x_train_res, y_train_res)

"""Proses training model menggunakan gridsearch sebagai hyperparameter tuning untuk mendapatkan parameter terbaik dari parameter yang sudah dideklarasikan sebelumnya."""

# Best parameters and accuracy
print("Best Parameters:", grid_search.best_params_)

"""parameter terbaik yang didapat dari hyperparameter tuning yang dilakukan menggunakan gridsearch

### EVALUASI MODEL SETELAH TUNING
"""

lstm = tf.keras.models.Sequential()
lstm.add(tf.keras.layers.LSTM(units=32, activation='relu', input_shape=(x_train_res.shape[1], x_train_res.shape[2]), return_sequences=True))
lstm.add(tf.keras.layers.Dropout(0.6))
lstm.add(tf.keras.layers.LSTM(units=16, activation='relu'))
lstm.add(tf.keras.layers.Dropout(0.6))
lstm.add(tf.keras.layers.Dense(units=1, activation='sigmoid'))
lstm.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Train the model
lstm_history = lstm.fit(x_train_res, y_train_res, batch_size=25, epochs=150, validation_split=0.2)

# Evaluate the training and validation loss
loss_train = lstm_history.history['loss']
loss_val = lstm_history.history['val_loss']
epochs = range(1, 151)

plt.plot(epochs, loss_train, 'g', label='Training loss')
plt.plot(epochs, loss_val, 'b', label='Validation loss')
plt.title('Training and Validation Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.legend()
plt.show()

# Evaluate the training and validation accuracy
acc_train = lstm_history.history['accuracy']
acc_val = lstm_history.history['val_accuracy']

plt.plot(epochs, acc_train, 'g', label='Training accuracy')
plt.plot(epochs, acc_val, 'b', label='Validation accuracy')
plt.title('Training and Validation Accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.legend()
plt.show()

print("Shape of x_train_res:", x_train_res.shape)
print("Shape of x_test:", x_test.shape)

# Reshape x_test
x_test = x_test.reshape((x_test.shape[0], 1, x_test.shape[1]))

# Make predictions
y_pred = lstm.predict(x_test)

# Convert probabilities to binary predictions
y_pred = (y_pred > 0.5).astype(int)

# Evaluate predictions
print(y_pred)

# Calculate accuracy score
accuracy = accuracy_score(y_test, y_pred)
print('Accuracy: {:.2f} %'.format(accuracy * 100))

# Confusion Matrix
cm = confusion_matrix(y_test, y_pred)
print('Confusion Matrix:\n', cm)

# Visualizing the Confusion Matrix
plt.figure(figsize=(8, 5))
sns.heatmap(cm, cmap='Blues', annot=True, fmt='d', linewidths=5, cbar=False, annot_kws={'fontsize': 15},
            yticklabels=['No Stroke', 'Stroke'], xticklabels=['Predicted No Stroke', 'Predicted Stroke'])
plt.yticks(rotation=0)
plt.title('Confusion Matrix')
plt.show()

"""Hasil dari evaluasi model setelah hyperparameter tuning ini mendapatkan akurasi 80.63% dan confusion matrix seperti gambar diatas ini.

# KESIMPULAN

Tanpa penerapan hyperparameter tuning, model XGBoost menunjukkan performa terbaik dengan akurasi 91%, diikuti oleh Random Forest dan LSTM yang masing-masing mencapai 90%. Model-model ini unggul berkat kemampuannya dalam menangkap pola kompleks dan hubungan temporal dalam data, dengan XGBoost dan Random Forest menggunakan teknik ensemble untuk mengurangi overfitting, serta LSTM yang cocok untuk data berurutan. Sementara itu, model seperti Gaussian Naive Bayes dan KNN memiliki performa yang lebih rendah, dengan Naive Bayes bahkan mengalami penurunan drastis pada distribusi Gaussian. Model-model sederhana seperti Logistic Regression dan SVM memberikan hasil yang cukup baik tetapi kalah dibandingkan model ensemble atau jaringan saraf yang lebih kompleks.

Setelah penerapan hyperparameter tuning menggunakan GridSearch, Random Forest dan XGBoost mencatatkan akurasi tertinggi sebesar 95.97% dan 95.84%, menunjukkan bahwa tuning dapat secara signifikan meningkatkan performa model. Kedua model ini lebih stabil dan andal dalam menangani data non-linear dan noise berkat teknik ensemble dan boosting. Model KNN juga mengalami peningkatan, mencapai akurasi 93%, sementara model lainnya seperti ANN, SVM, dan Decision Tree menunjukkan hasil yang baik pada area tertentu. Namun, Naive Bayes dan RNN masih memiliki performa yang rendah, terutama karena asumsi distribusi yang tidak sesuai dengan data.

Secara keseluruhan, penerapan hyperparameter tuning dengan GridSearch memberikan hasil yang lebih optimal, dengan Random Forest dan XGBoost sebagai model unggulan untuk akurasi tertinggi, sedangkan Decision Tree dapat menjadi pilihan jika interpretabilitas dibutuhkan dan LSTM cocok untuk analisis data sekuensial atau temporal dalam prediksi stroke.

------------------------------------------------------------------------
"""